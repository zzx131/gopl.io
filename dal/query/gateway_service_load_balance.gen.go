// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gopl.io/dal/model"
)

func newGatewayServiceLoadBalance(db *gorm.DB) gatewayServiceLoadBalance {
	_gatewayServiceLoadBalance := gatewayServiceLoadBalance{}

	_gatewayServiceLoadBalance.gatewayServiceLoadBalanceDo.UseDB(db)
	_gatewayServiceLoadBalance.gatewayServiceLoadBalanceDo.UseModel(&model.GatewayServiceLoadBalance{})

	tableName := _gatewayServiceLoadBalance.gatewayServiceLoadBalanceDo.TableName()
	_gatewayServiceLoadBalance.ALL = field.NewField(tableName, "*")
	_gatewayServiceLoadBalance.ID = field.NewInt64(tableName, "id")
	_gatewayServiceLoadBalance.ServiceID = field.NewInt64(tableName, "service_id")
	_gatewayServiceLoadBalance.CheckMethod = field.NewInt8(tableName, "check_method")
	_gatewayServiceLoadBalance.CheckTimeout = field.NewInt64(tableName, "check_timeout")
	_gatewayServiceLoadBalance.CheckInterval = field.NewInt64(tableName, "check_interval")
	_gatewayServiceLoadBalance.RoundType = field.NewInt8(tableName, "round_type")
	_gatewayServiceLoadBalance.IPList = field.NewString(tableName, "ip_list")
	_gatewayServiceLoadBalance.WeightList = field.NewString(tableName, "weight_list")
	_gatewayServiceLoadBalance.ForbidList = field.NewString(tableName, "forbid_list")
	_gatewayServiceLoadBalance.UpstreamConnectTimeout = field.NewInt64(tableName, "upstream_connect_timeout")
	_gatewayServiceLoadBalance.UpstreamHeaderTimeout = field.NewInt64(tableName, "upstream_header_timeout")
	_gatewayServiceLoadBalance.UpstreamIdleTimeout = field.NewInt64(tableName, "upstream_idle_timeout")
	_gatewayServiceLoadBalance.UpstreamMaxIdle = field.NewInt64(tableName, "upstream_max_idle")

	_gatewayServiceLoadBalance.fillFieldMap()

	return _gatewayServiceLoadBalance
}

type gatewayServiceLoadBalance struct {
	gatewayServiceLoadBalanceDo gatewayServiceLoadBalanceDo

	ALL                    field.Field
	ID                     field.Int64
	ServiceID              field.Int64
	CheckMethod            field.Int8
	CheckTimeout           field.Int64
	CheckInterval          field.Int64
	RoundType              field.Int8
	IPList                 field.String
	WeightList             field.String
	ForbidList             field.String
	UpstreamConnectTimeout field.Int64
	UpstreamHeaderTimeout  field.Int64
	UpstreamIdleTimeout    field.Int64
	UpstreamMaxIdle        field.Int64

	fieldMap map[string]field.Expr
}

func (g gatewayServiceLoadBalance) Table(newTableName string) *gatewayServiceLoadBalance {
	g.gatewayServiceLoadBalanceDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g gatewayServiceLoadBalance) As(alias string) *gatewayServiceLoadBalance {
	g.gatewayServiceLoadBalanceDo.DO = *(g.gatewayServiceLoadBalanceDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *gatewayServiceLoadBalance) updateTableName(table string) *gatewayServiceLoadBalance {
	g.ALL = field.NewField(table, "*")
	g.ID = field.NewInt64(table, "id")
	g.ServiceID = field.NewInt64(table, "service_id")
	g.CheckMethod = field.NewInt8(table, "check_method")
	g.CheckTimeout = field.NewInt64(table, "check_timeout")
	g.CheckInterval = field.NewInt64(table, "check_interval")
	g.RoundType = field.NewInt8(table, "round_type")
	g.IPList = field.NewString(table, "ip_list")
	g.WeightList = field.NewString(table, "weight_list")
	g.ForbidList = field.NewString(table, "forbid_list")
	g.UpstreamConnectTimeout = field.NewInt64(table, "upstream_connect_timeout")
	g.UpstreamHeaderTimeout = field.NewInt64(table, "upstream_header_timeout")
	g.UpstreamIdleTimeout = field.NewInt64(table, "upstream_idle_timeout")
	g.UpstreamMaxIdle = field.NewInt64(table, "upstream_max_idle")

	g.fillFieldMap()

	return g
}

func (g *gatewayServiceLoadBalance) WithContext(ctx context.Context) *gatewayServiceLoadBalanceDo {
	return g.gatewayServiceLoadBalanceDo.WithContext(ctx)
}

func (g gatewayServiceLoadBalance) TableName() string {
	return g.gatewayServiceLoadBalanceDo.TableName()
}

func (g gatewayServiceLoadBalance) Alias() string { return g.gatewayServiceLoadBalanceDo.Alias() }

func (g *gatewayServiceLoadBalance) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *gatewayServiceLoadBalance) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 13)
	g.fieldMap["id"] = g.ID
	g.fieldMap["service_id"] = g.ServiceID
	g.fieldMap["check_method"] = g.CheckMethod
	g.fieldMap["check_timeout"] = g.CheckTimeout
	g.fieldMap["check_interval"] = g.CheckInterval
	g.fieldMap["round_type"] = g.RoundType
	g.fieldMap["ip_list"] = g.IPList
	g.fieldMap["weight_list"] = g.WeightList
	g.fieldMap["forbid_list"] = g.ForbidList
	g.fieldMap["upstream_connect_timeout"] = g.UpstreamConnectTimeout
	g.fieldMap["upstream_header_timeout"] = g.UpstreamHeaderTimeout
	g.fieldMap["upstream_idle_timeout"] = g.UpstreamIdleTimeout
	g.fieldMap["upstream_max_idle"] = g.UpstreamMaxIdle
}

func (g gatewayServiceLoadBalance) clone(db *gorm.DB) gatewayServiceLoadBalance {
	g.gatewayServiceLoadBalanceDo.ReplaceDB(db)
	return g
}

type gatewayServiceLoadBalanceDo struct{ gen.DO }

func (g gatewayServiceLoadBalanceDo) Debug() *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Debug())
}

func (g gatewayServiceLoadBalanceDo) WithContext(ctx context.Context) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g gatewayServiceLoadBalanceDo) Clauses(conds ...clause.Expression) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g gatewayServiceLoadBalanceDo) Returning(value interface{}, columns ...string) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g gatewayServiceLoadBalanceDo) Not(conds ...gen.Condition) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g gatewayServiceLoadBalanceDo) Or(conds ...gen.Condition) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g gatewayServiceLoadBalanceDo) Select(conds ...field.Expr) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g gatewayServiceLoadBalanceDo) Where(conds ...gen.Condition) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g gatewayServiceLoadBalanceDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *gatewayServiceLoadBalanceDo {
	return g.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (g gatewayServiceLoadBalanceDo) Order(conds ...field.Expr) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g gatewayServiceLoadBalanceDo) Distinct(cols ...field.Expr) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g gatewayServiceLoadBalanceDo) Omit(cols ...field.Expr) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g gatewayServiceLoadBalanceDo) Join(table schema.Tabler, on ...field.Expr) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g gatewayServiceLoadBalanceDo) LeftJoin(table schema.Tabler, on ...field.Expr) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g gatewayServiceLoadBalanceDo) RightJoin(table schema.Tabler, on ...field.Expr) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g gatewayServiceLoadBalanceDo) Group(cols ...field.Expr) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g gatewayServiceLoadBalanceDo) Having(conds ...gen.Condition) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g gatewayServiceLoadBalanceDo) Limit(limit int) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g gatewayServiceLoadBalanceDo) Offset(offset int) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g gatewayServiceLoadBalanceDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g gatewayServiceLoadBalanceDo) Unscoped() *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Unscoped())
}

func (g gatewayServiceLoadBalanceDo) Create(values ...*model.GatewayServiceLoadBalance) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g gatewayServiceLoadBalanceDo) CreateInBatches(values []*model.GatewayServiceLoadBalance, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g gatewayServiceLoadBalanceDo) Save(values ...*model.GatewayServiceLoadBalance) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g gatewayServiceLoadBalanceDo) First() (*model.GatewayServiceLoadBalance, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GatewayServiceLoadBalance), nil
	}
}

func (g gatewayServiceLoadBalanceDo) Take() (*model.GatewayServiceLoadBalance, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GatewayServiceLoadBalance), nil
	}
}

func (g gatewayServiceLoadBalanceDo) Last() (*model.GatewayServiceLoadBalance, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GatewayServiceLoadBalance), nil
	}
}

func (g gatewayServiceLoadBalanceDo) Find() ([]*model.GatewayServiceLoadBalance, error) {
	result, err := g.DO.Find()
	return result.([]*model.GatewayServiceLoadBalance), err
}

func (g gatewayServiceLoadBalanceDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GatewayServiceLoadBalance, err error) {
	buf := make([]*model.GatewayServiceLoadBalance, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g gatewayServiceLoadBalanceDo) FindInBatches(result *[]*model.GatewayServiceLoadBalance, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g gatewayServiceLoadBalanceDo) Attrs(attrs ...field.AssignExpr) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g gatewayServiceLoadBalanceDo) Assign(attrs ...field.AssignExpr) *gatewayServiceLoadBalanceDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g gatewayServiceLoadBalanceDo) Joins(fields ...field.RelationField) *gatewayServiceLoadBalanceDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g gatewayServiceLoadBalanceDo) Preload(fields ...field.RelationField) *gatewayServiceLoadBalanceDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g gatewayServiceLoadBalanceDo) FirstOrInit() (*model.GatewayServiceLoadBalance, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GatewayServiceLoadBalance), nil
	}
}

func (g gatewayServiceLoadBalanceDo) FirstOrCreate() (*model.GatewayServiceLoadBalance, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GatewayServiceLoadBalance), nil
	}
}

func (g gatewayServiceLoadBalanceDo) FindByPage(offset int, limit int) (result []*model.GatewayServiceLoadBalance, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g gatewayServiceLoadBalanceDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g *gatewayServiceLoadBalanceDo) withDO(do gen.Dao) *gatewayServiceLoadBalanceDo {
	g.DO = *do.(*gen.DO)
	return g
}
